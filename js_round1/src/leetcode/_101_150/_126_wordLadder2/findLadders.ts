// https://leetcode.com/problems/word-ladder-ii/

function findLadders(
  beginWord: string,
  endWord: string,
  wordList: string[]
): string[][] {
  const vertex = new Set<string>();
  const graph = new Map<string, Set<string>>();

  const depth = BFSBuildGraph(beginWord, endWord, wordList, vertex, graph);

  if (depth === -1) {
    return [];
  }

  const result: string[][] = [];
  DFSSearch1(beginWord, endWord, graph, depth, result);
  return result;
}

function BFSBuildGraph(
  beginWord,
  endWord,
  wordList,
  vertex: Set<string>,
  graph: Map<string, Set<string>>
): number {
  const wordSet = new Set(wordList);
  const queue: string[] = [beginWord];
  let depth = 0;
  vertex.add(beginWord);
  let stopAtCurrentLevel = false;
  while (queue.length > 0 && !stopAtCurrentLevel) {
    depth++;
    const queueLength = queue.length;
    for (let i = 0; i < queueLength; i++) {
      // these word already traversed in previous level
      vertex.add(queue[i]);
    }

    const seenInCurrentLevel = new Set<string>();
    for (let i = 0; i < queueLength; i++) {
      const word = queue.shift()!;

      for (let i = 0; i < word.length; i++) {
        const charArr = word.split('').map((char) => char.charCodeAt(0));
        for (let j = 97; j < 97 + 26; j++) {
          charArr[i] = j;
          const nextWord = String.fromCharCode(...charArr);

          if (wordSet.has(nextWord) && !vertex.has(nextWord)) {
            if (nextWord === endWord) {
              stopAtCurrentLevel = true;
            }
            if (!seenInCurrentLevel.has(nextWord)) {
              queue.push(nextWord);
              seenInCurrentLevel.add(nextWord);
            }
            if (!graph.has(word)) {
              graph.set(word, new Set<string>());
            }
            graph.get(word)?.add(nextWord);
          }
        }
      }
    }
  }
  if (stopAtCurrentLevel) {
    vertex.add(endWord);
  }

  if (!vertex.has(endWord)) {
    return -1;
  }

  return depth + 1;
}

function DFSSearch1(
  beginWord: string,
  endWord: string,
  graph: Map<string, Set<string>>,
  maxDepth: number,
  result: string[][],
  currentTrace: string[] = [beginWord]
) {
  if (beginWord === endWord) {
    result.push(currentTrace);
    return;
  }

  if (currentTrace.length >= maxDepth) {
    return;
  }

  const edges = graph.get(beginWord)!;
  for (const word of edges) {
    const tempTrace = [...currentTrace, word];
    DFSSearch1(word, endWord, graph, maxDepth, result, tempTrace);
  }
}

const beginWord = 'aaaaa';
const endWord = 'ggggg';
const wordList = [
  'aaaaa',
  'caaaa',
  'cbaaa',
  'daaaa',
  'dbaaa',
  'eaaaa',
  'ebaaa',
  'faaaa',
  'fbaaa',
  'gaaaa',
  'gbaaa',
  'haaaa',
  'hbaaa',
  'iaaaa',
  'ibaaa',
  'jaaaa',
  'jbaaa',
  'kaaaa',
  'kbaaa',
  'laaaa',
  'lbaaa',
  'maaaa',
  'mbaaa',
  'naaaa',
  'nbaaa',
  'oaaaa',
  'obaaa',
  'paaaa',
  'pbaaa',
  'bbaaa',
  'bbcaa',
  'bbcba',
  'bbdaa',
  'bbdba',
  'bbeaa',
  'bbeba',
  'bbfaa',
  'bbfba',
  'bbgaa',
  'bbgba',
  'bbhaa',
  'bbhba',
  'bbiaa',
  'bbiba',
  'bbjaa',
  'bbjba',
  'bbkaa',
  'bbkba',
  'bblaa',
  'bblba',
  'bbmaa',
  'bbmba',
  'bbnaa',
  'bbnba',
  'bboaa',
  'bboba',
  'bbpaa',
  'bbpba',
  'bbbba',
  'abbba',
  'acbba',
  'dbbba',
  'dcbba',
  'ebbba',
  'ecbba',
  'fbbba',
  'fcbba',
  'gbbba',
  'gcbba',
  'hbbba',
  'hcbba',
  'ibbba',
  'icbba',
  'jbbba',
  'jcbba',
  'kbbba',
  'kcbba',
  'lbbba',
  'lcbba',
  'mbbba',
  'mcbba',
  'nbbba',
  'ncbba',
  'obbba',
  'ocbba',
  'pbbba',
  'pcbba',
  'ccbba',
  'ccaba',
  'ccaca',
  'ccdba',
  'ccdca',
  'cceba',
  'cceca',
  'ccfba',
  'ccfca',
  'ccgba',
  'ccgca',
  'cchba',
  'cchca',
  'cciba',
  'ccica',
  'ccjba',
  'ccjca',
  'cckba',
  'cckca',
  'cclba',
  'cclca',
  'ccmba',
  'ccmca',
  'ccnba',
  'ccnca',
  'ccoba',
  'ccoca',
  'ccpba',
  'ccpca',
  'cccca',
  'accca',
  'adcca',
  'bccca',
  'bdcca',
  'eccca',
  'edcca',
  'fccca',
  'fdcca',
  'gccca',
  'gdcca',
  'hccca',
  'hdcca',
  'iccca',
  'idcca',
  'jccca',
  'jdcca',
  'kccca',
  'kdcca',
  'lccca',
  'ldcca',
  'mccca',
  'mdcca',
  'nccca',
  'ndcca',
  'occca',
  'odcca',
  'pccca',
  'pdcca',
  'ddcca',
  'ddaca',
  'ddada',
  'ddbca',
  'ddbda',
  'ddeca',
  'ddeda',
  'ddfca',
  'ddfda',
  'ddgca',
  'ddgda',
  'ddhca',
  'ddhda',
  'ddica',
  'ddida',
  'ddjca',
  'ddjda',
  'ddkca',
  'ddkda',
  'ddlca',
  'ddlda',
  'ddmca',
  'ddmda',
  'ddnca',
  'ddnda',
  'ddoca',
  'ddoda',
  'ddpca',
  'ddpda',
  'dddda',
  'addda',
  'aedda',
  'bddda',
  'bedda',
  'cddda',
  'cedda',
  'fddda',
  'fedda',
  'gddda',
  'gedda',
  'hddda',
  'hedda',
  'iddda',
  'iedda',
  'jddda',
  'jedda',
  'kddda',
  'kedda',
  'lddda',
  'ledda',
  'mddda',
  'medda',
  'nddda',
  'nedda',
  'oddda',
  'oedda',
  'pddda',
  'pedda',
  'eedda',
  'eeada',
  'eeaea',
  'eebda',
  'eebea',
  'eecda',
  'eecea',
  'eefda',
  'eefea',
  'eegda',
  'eegea',
  'eehda',
  'eehea',
  'eeida',
  'eeiea',
  'eejda',
  'eejea',
  'eekda',
  'eekea',
  'eelda',
  'eelea',
  'eemda',
  'eemea',
  'eenda',
  'eenea',
  'eeoda',
  'eeoea',
  'eepda',
  'eepea',
  'eeeea',
  'ggggg',
  'agggg',
  'ahggg',
  'bgggg',
  'bhggg',
  'cgggg',
  'chggg',
  'dgggg',
  'dhggg',
  'egggg',
  'ehggg',
  'fgggg',
  'fhggg',
  'igggg',
  'ihggg',
  'jgggg',
  'jhggg',
  'kgggg',
  'khggg',
  'lgggg',
  'lhggg',
  'mgggg',
  'mhggg',
  'ngggg',
  'nhggg',
  'ogggg',
  'ohggg',
  'pgggg',
  'phggg',
  'hhggg',
  'hhagg',
  'hhahg',
  'hhbgg',
  'hhbhg',
  'hhcgg',
  'hhchg',
  'hhdgg',
  'hhdhg',
  'hhegg',
  'hhehg',
  'hhfgg',
  'hhfhg',
  'hhigg',
  'hhihg',
  'hhjgg',
  'hhjhg',
  'hhkgg',
  'hhkhg',
  'hhlgg',
  'hhlhg',
  'hhmgg',
  'hhmhg',
  'hhngg',
  'hhnhg',
  'hhogg',
  'hhohg',
  'hhpgg',
  'hhphg',
  'hhhhg',
  'ahhhg',
  'aihhg',
  'bhhhg',
  'bihhg',
  'chhhg',
  'cihhg',
  'dhhhg',
  'dihhg',
  'ehhhg',
  'eihhg',
  'fhhhg',
  'fihhg',
  'ghhhg',
  'gihhg',
  'jhhhg',
  'jihhg',
  'khhhg',
  'kihhg',
  'lhhhg',
  'lihhg',
  'mhhhg',
  'mihhg',
  'nhhhg',
  'nihhg',
  'ohhhg',
  'oihhg',
  'phhhg',
  'pihhg',
  'iihhg',
  'iiahg',
  'iiaig',
  'iibhg',
  'iibig',
  'iichg',
  'iicig',
  'iidhg',
  'iidig',
  'iiehg',
  'iieig',
  'iifhg',
  'iifig',
  'iighg',
  'iigig',
  'iijhg',
  'iijig',
  'iikhg',
  'iikig',
  'iilhg',
  'iilig',
  'iimhg',
  'iimig',
  'iinhg',
  'iinig',
  'iiohg',
  'iioig',
  'iiphg',
  'iipig',
  'iiiig',
  'aiiig',
  'ajiig',
  'biiig',
  'bjiig',
  'ciiig',
  'cjiig',
  'diiig',
  'djiig',
  'eiiig',
  'ejiig',
  'fiiig',
  'fjiig',
  'giiig',
  'gjiig',
  'hiiig',
  'hjiig',
  'kiiig',
  'kjiig',
  'liiig',
  'ljiig',
  'miiig',
  'mjiig',
  'niiig',
  'njiig',
  'oiiig',
  'ojiig',
  'piiig',
  'pjiig',
  'jjiig',
  'jjaig',
  'jjajg',
  'jjbig',
  'jjbjg',
  'jjcig',
  'jjcjg',
  'jjdig',
  'jjdjg',
  'jjeig',
  'jjejg',
  'jjfig',
  'jjfjg',
  'jjgig',
  'jjgjg',
  'jjhig',
  'jjhjg',
  'jjkig',
  'jjkjg',
  'jjlig',
  'jjljg',
  'jjmig',
  'jjmjg',
  'jjnig',
  'jjnjg',
  'jjoig',
  'jjojg',
  'jjpig',
  'jjpjg',
  'jjjjg',
  'ajjjg',
  'akjjg',
  'bjjjg',
  'bkjjg',
  'cjjjg',
  'ckjjg',
  'djjjg',
  'dkjjg',
  'ejjjg',
  'ekjjg',
  'fjjjg',
  'fkjjg',
  'gjjjg',
  'gkjjg',
  'hjjjg',
  'hkjjg',
  'ijjjg',
  'ikjjg',
  'ljjjg',
  'lkjjg',
  'mjjjg',
  'mkjjg',
  'njjjg',
  'nkjjg',
  'ojjjg',
  'okjjg',
  'pjjjg',
  'pkjjg',
  'kkjjg',
  'kkajg',
  'kkakg',
  'kkbjg',
  'kkbkg',
  'kkcjg',
  'kkckg',
  'kkdjg',
  'kkdkg',
  'kkejg',
  'kkekg',
  'kkfjg',
  'kkfkg',
  'kkgjg',
  'kkgkg',
  'kkhjg',
  'kkhkg',
  'kkijg',
  'kkikg',
  'kkljg',
  'kklkg',
  'kkmjg',
  'kkmkg',
  'kknjg',
  'kknkg',
  'kkojg',
  'kkokg',
  'kkpjg',
  'kkpkg',
  'kkkkg',
  'ggggx',
  'gggxx',
  'ggxxx',
  'gxxxx',
  'xxxxx',
  'xxxxy',
  'xxxyy',
  'xxyyy',
  'xyyyy',
  'yyyyy',
  'yyyyw',
  'yyyww',
  'yywww',
  'ywwww',
  'wwwww',
  'wwvww',
  'wvvww',
  'vvvww',
  'vvvwz',
  'avvwz',
  'aavwz',
  'aaawz',
  'aaaaz',
];

// console.log(findLadders(beginWord, endWord, wordList));

export default findLadders;
